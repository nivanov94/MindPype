<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bcipy.source &mdash; bcipy 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            bcipy
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Getting Started with BCIPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#setup-guide">Setup Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#basic-setup">Basic Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bcipy.html">bcipy package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">bcipy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bcipy.source</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bcipy.source</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Currently supported sources:</span>
<span class="sd">    - Lab Streaming Layer</span>
<span class="sd">    - mat files</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO: Enhance file based classes to enable bulk read (i.e. multiple trial)</span>
<span class="c1"># capabilities</span>


<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">BCIP</span><span class="p">,</span> <span class="n">BcipEnums</span>
<span class="kn">from</span> <span class="nn">.containers</span> <span class="kn">import</span> <span class="n">CircleBuffer</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">loadmat</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylsl</span>
<span class="kn">import</span> <span class="nn">pyxdf</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>

<div class="viewcode-block" id="BcipMatFile"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipMatFile">[docs]</a><span class="k">class</span> <span class="nc">BcipMatFile</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility for extracting data from a mat file for BCIP</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">label_varname_map</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new mat file reader interface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="n">path</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="c1"># TODO log error</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;File </span><span class="si">{}</span><span class="s2"> not found in dir </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">path</span><span class="p">))</span>
            <span class="k">return</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">filepath</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="n">dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_data</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># check if the variable names exist in the file</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting up source from file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file_data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filepath</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">varname</span> <span class="ow">in</span> <span class="n">label_varname_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">varname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_data</span><span class="p">:</span>
                <span class="c1"># TODO log error</span>
                <span class="k">return</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># check that the data has the correct number of dimensions</span>
                <span class="n">data_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_data</span><span class="p">[</span><span class="n">varname</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)):</span>
                    <span class="n">min_channel</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">max_channel</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    
                    <span class="c1"># ignore the first data dimension b/c its the trial number</span>
                    <span class="k">if</span> <span class="n">min_channel</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_channel</span> <span class="o">&gt;=</span> <span class="n">data_dims</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> \
                       <span class="ow">or</span> <span class="n">max_channel</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">max_channel</span> <span class="o">&gt;=</span> <span class="n">data_dims</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                           <span class="c1"># TODO log error</span>
                           <span class="k">return</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">label_varname_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># copy the dictionary - converting any string keys into ints</span>
        <span class="c1"># a bit hacky, but makes it easier to create MAT file objs with the JSON parser</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">label_varname_map</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_varname_map</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">label_varname_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_varname_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">label_varname_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_varname_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        
<div class="viewcode-block" id="BcipMatFile.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipMatFile.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Ns</span><span class="p">,</span><span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Poll the data for the next trial of the input label</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">class_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_varname_map</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get all the dimensions</span>
            <span class="n">trial_data</span> <span class="o">=</span> <span class="n">class_data</span><span class="p">[</span><span class="n">label</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">],:,:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">],),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">trial_data</span> <span class="o">=</span> <span class="n">class_data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        
        <span class="c1"># increment the label counter for this class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">trial_data</span></div>
    

<div class="viewcode-block" id="BcipMatFile.create"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipMatFile.create">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">label_varname_map</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method for API</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">path</span><span class="p">,</span><span class="n">label_varname_map</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span>
        
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div></div>

<div class="viewcode-block" id="BcipClassSeparatedMat"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipClassSeparatedMat">[docs]</a><span class="k">class</span> <span class="nc">BcipClassSeparatedMat</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for extracting class separated data from a mat file for BCIP. </span>

<span class="sd">    Parameters</span>

<span class="sd">    ----------</span>

<span class="sd">    sess : Session Object</span>
<span class="sd">        Session where the BcipClassSeparated data source will exist.</span>

<span class="sd">    num_classes : int</span>
<span class="sd">        Number of classes within the MAT data</span>

<span class="sd">    event_duration : int</span>
<span class="sd">        Number of samples during each trial. Should be equal to the number of samples divided by the number of trials, assuming no breaks between trials</span>

<span class="sd">    start_index : int</span>
<span class="sd">        Sample number at which the trial data to be used, begins. Data before the start_index sample within the MAT source will be ignored.</span>

<span class="sd">    end_index : int</span>
<span class="sd">        Sample number when the trial to be used, ends. Data after the end_index sample within the MAT source will be ignored</span>

<span class="sd">    relative_start : int</span>
<span class="sd">        Shift the beginning of each trial start by relative_start samples/</span>

<span class="sd">    mat_data_var_name : str</span>
<span class="sd">        Name of the mat data array within the .mat file.</span>

<span class="sd">    mat_labels_var_name : str</span>
<span class="sd">        Name of the labels array within the .mat file.</span>

<span class="sd">    link_to_data : str</span>
<span class="sd">        * Relative path of the mat data to be stored within the created object</span>

<span class="sd">    link_to_labels : str</span>
<span class="sd">        * Relative path of the labels data to be stored within the created object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    * Add traceback example with keyerror when mat_data_var_name is incorrect</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The imported MAT data to be stored within the object should be in the shape of Number of channels x Number of samples</span>
<span class="sd">    * The MAT labels array should be in the shape of Number of trials x 2, where the first column is the start index of each trial and the second column is the class label of each trial </span>
<span class="sd">        * The class label of each trial should be numeric.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">event_duration</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">mat_data_var_name</span><span class="p">,</span> <span class="n">mat_labels_var_name</span> <span class="p">,</span><span class="n">link_to_data</span><span class="p">,</span> <span class="n">link_to_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new mat file reader interface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">continuous_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_separated_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_to_data</span> <span class="o">=</span> <span class="n">link_to_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">link_to_labels</span> <span class="o">=</span> <span class="n">link_to_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_duration</span> <span class="o">=</span> <span class="n">event_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_data_var_name</span> <span class="o">=</span> <span class="n">mat_data_var_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_labels_var_name</span> <span class="o">=</span> <span class="n">mat_labels_var_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span> <span class="o">=</span> <span class="n">relative_start</span>

        <span class="k">if</span> <span class="n">link_to_labels</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">link_to_data</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">mat_data_var_name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">continuous_data</span> <span class="o">=</span> <span class="n">raw_data</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start and/or End index incorrect.&quot;</span><span class="p">)</span>

            <span class="n">labels</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">link_to_labels</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">mat_labels_var_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">link_to_labels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">link_to_data</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="n">mat_labels_var_name</span><span class="p">])</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">mat_data_var_name</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:,</span> <span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start and/or End index incorrect.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>            


        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">start_index</span><span class="p">:</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">end_index</span><span class="p">:</span>
                <span class="n">last_row</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>


        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">first_row</span><span class="p">:</span><span class="n">last_row</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">labels_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="n">labels_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="n">num_classes</span><span class="p">:</span>
                <span class="k">break</span>
 
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">labels_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)],</span> <span class="n">index</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labels_dict</span> <span class="o">=</span> <span class="n">labels_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span> <span class="o">=</span> <span class="n">raw_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>

<div class="viewcode-block" id="BcipClassSeparatedMat.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipClassSeparatedMat.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">trial_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels_dict</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">)</span>
            <span class="n">trial_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_data</span><span class="p">[:,</span><span class="nb">int</span><span class="p">(</span><span class="n">trial_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">trial_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_duration</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counters</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">trial_data</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Label does not exist&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BcipEnums</span><span class="o">.</span><span class="n">EXE_FAILURE</span></div>


<div class="viewcode-block" id="BcipClassSeparatedMat.format_continuous_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipClassSeparatedMat.format_continuous_data">[docs]</a>    <span class="k">def</span> <span class="nf">format_continuous_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_to_data</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_data_var_name</span><span class="p">])</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">link_to_labels</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mat_labels_var_name</span><span class="p">])</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">data_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_duration</span><span class="p">)]</span> <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">raw_data</span> <span class="p">]</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="mi">0</span><span class="p">])],</span> <span class="n">data_to_add</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">class_separated_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">]</span></div>

<div class="viewcode-block" id="BcipClassSeparatedMat.create_class_separated"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipClassSeparatedMat.create_class_separated">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_class_separated</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">event_duration</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">mat_data_var_name</span><span class="p">,</span> <span class="n">mat_labels_var_name</span><span class="p">,</span> <span class="n">link_to_data</span><span class="p">,</span> <span class="n">link_to_labels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory Method for creating class separated MAT File input source. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sess : Session Object</span>
<span class="sd">            Session where the BcipClassSeparated data source will exist.</span>

<span class="sd">        num_classes : int</span>
<span class="sd">            Number of classes within the MAT data</span>

<span class="sd">        event_duration : int</span>
<span class="sd">            Number of samples during each trial. Should be equal to the number of samples divided by the number of trials, assuming no breaks between trials</span>

<span class="sd">        start_index : int</span>
<span class="sd">            Sample number at which the trial data to be used, begins. Data before the start_index sample within the MAT source will be ignored.</span>

<span class="sd">        end_index : int</span>
<span class="sd">            Sample number when the trial to be used, ends. Data after the end_index sample within the MAT source will be ignored</span>

<span class="sd">        relative_start : int</span>
<span class="sd">            Shift the beginning of each trial start by relative_start samples/</span>

<span class="sd">        mat_data_var_name : str</span>
<span class="sd">            Name of the mat data array within the .mat file.</span>

<span class="sd">        mat_labels_var_name : str</span>
<span class="sd">            Name of the labels array within the .mat file.</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        link_to_data : str</span>
<span class="sd">            Relative path of the mat data to be stored within the created object.</span>


<span class="sd">        link_to_labels : str</span>
<span class="sd">            Relative path of the labels data to be stored within the created object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        * Add traceback example with keyerror when mat_data_var_name is incorrect</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The imported MAT data to be stored within the object should be in the shape of Number of channels x Number of samples</span>
<span class="sd">        * The MAT labels array should be in the shape of Number of trials x 2, where the first column is the start index of each trial and the second column is the class label of each trial </span>
<span class="sd">            * The class label of each trial should be numeric.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">event_duration</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">mat_data_var_name</span><span class="p">,</span> <span class="n">mat_labels_var_name</span> <span class="p">,</span><span class="n">link_to_data</span><span class="p">,</span> <span class="n">link_to_labels</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span></div></div>

<div class="viewcode-block" id="BcipContinuousMat"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipContinuousMat">[docs]</a><span class="k">class</span> <span class="nc">BcipContinuousMat</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for extracting continuous from a mat file for BCIP. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    sess : Session Object</span>
<span class="sd">        Session where the BcipClassSeparated data source will exist.</span>

<span class="sd">    event_duration : int</span>
<span class="sd">        Number of samples during each trial. Should be equal to the number of samples divided by the number of trials, assuming no breaks between trials</span>

<span class="sd">    start_index : int</span>
<span class="sd">        Sample number at which the trial data to be used, begins. Data before the start_index sample within the MAT source will be ignored.</span>

<span class="sd">    end_index : int</span>
<span class="sd">        Sample number when the trial to be used, ends. Data after the end_index sample within the MAT source will be ignored</span>

<span class="sd">    relative_start : int</span>
<span class="sd">        Shift the beginning of each trial start by relative_start samples/</span>

<span class="sd">    mat_data_var_name : str</span>
<span class="sd">        Name of the mat data array within the .mat file.</span>

<span class="sd">    mat_labels_var_name : str</span>
<span class="sd">        Name of the labels array within the .mat file.</span>

<span class="sd">    data_filename : str</span>
<span class="sd">        Relative path of the mat data to be stored within the created object</span>

<span class="sd">    label_filename : str</span>
<span class="sd">        Relative path of the labels data to be stored within the created object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    --&gt; Add traceback example with keyerror when mat_data_var_name is incorrect</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    --&gt; The imported MAT data to be stored within the object should be in the shape of Number of channels x Number of samples</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">event_duration</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">mat_data_var_name</span><span class="p">,</span> <span class="n">mat_labels_var_name</span> <span class="p">,</span><span class="n">data_filename</span><span class="p">,</span> <span class="n">label_filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new mat file reader interface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_filename</span> <span class="o">=</span> <span class="n">data_filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_filename</span> <span class="o">=</span> <span class="n">label_filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">event_duration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_data_var_name</span> <span class="o">=</span> <span class="n">mat_data_var_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mat_labels_var_name</span> <span class="o">=</span> <span class="n">mat_labels_var_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">relative_start</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">data_filename</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="n">mat_data_var_name</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,:]</span>
        <span class="n">Nc</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">end_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">Ns</span> <span class="o">+</span> <span class="n">end_index</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># extract the segment defined by the start and end indices</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start and/or End index invalid.&quot;</span><span class="p">)</span>
            <span class="c1"># TODO error log, should probably raise an error here too</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">label_filename</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># labels should be 2D array, first column contain the label, second column contain the timestamp of the label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">label_filename</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="n">mat_labels_var_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># labels assumed to be in the same file as data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">loadmat</span><span class="p">(</span><span class="n">data_filename</span><span class="p">,</span> <span class="n">mat_dtype</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">struct_as_record</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)[</span><span class="n">mat_labels_var_name</span><span class="p">]</span>

        <span class="c1"># remove labels that are not within the start and end indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">end_index</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">start_index</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_trial_counter</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="BcipContinuousMat.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipContinuousMat.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trial_counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_duration</span>
            <span class="n">trial_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">start</span> <span class="p">:</span> <span class="n">end</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trial_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">trial_data</span>

        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="c1"># TODO fix bad return type format, log error, raise exception</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Trial data does not exist here. Please ensure you are not polling at time samples outside the provided data&#39;s region.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">BcipEnums</span><span class="o">.</span><span class="n">EXE_FAILURE</span></div>

<div class="viewcode-block" id="BcipContinuousMat.get_next_label"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipContinuousMat.get_next_label">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trial_counter</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="BcipContinuousMat.create_continuous"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipContinuousMat.create_continuous">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_continuous</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">data_filename</span><span class="p">,</span> <span class="n">event_duration</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
                          <span class="n">end_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">mat_data_var_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                          <span class="n">mat_labels_var_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">label_filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Factory Method for creating continuous MAT File input source. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        sess : Session Object</span>
<span class="sd">            Session where the BcipClassSeparated data source will exist.</span>

<span class="sd">        event_duration : int</span>
<span class="sd">            Number of samples during each trial. Should be equal to the number of samples divided by the number of trials, assuming no breaks between trials</span>

<span class="sd">        relative_start : int</span>
<span class="sd">            Shift the beginning of each trial start by relative_start samples/</span>
<span class="sd">        </span>
<span class="sd">        start_index : int</span>
<span class="sd">            Sample number at which the trial data to be used, begins. Data before the start_index sample within the MAT source will be ignored.</span>

<span class="sd">        end_index : int</span>
<span class="sd">            Sample number when the trial to be used, ends. Data after the end_index sample within the MAT source will be ignored</span>

<span class="sd">        channels : tuple of ints</span>
<span class="sd">            Channel indices to sample</span>

<span class="sd">        mat_data_var_name : str</span>
<span class="sd">            Name of the mat data array within the .mat file.</span>

<span class="sd">        mat_labels_var_name : str</span>
<span class="sd">            Name of the labels array within the .mat file.</span>

<span class="sd">        data_filename : str</span>
<span class="sd">            Relative path of the mat data to be stored within the created object</span>

<span class="sd">        label_filename : str</span>
<span class="sd">            Relative path of the labels data to be stored within the created object.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">event_duration</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> 
                  <span class="n">relative_start</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">mat_data_var_name</span><span class="p">,</span> 
                  <span class="n">mat_labels_var_name</span><span class="p">,</span> <span class="n">data_filename</span><span class="p">,</span> <span class="n">label_filename</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span></div></div>


<div class="viewcode-block" id="BcipXDF"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipXDF">[docs]</a><span class="k">class</span> <span class="nc">BcipXDF</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility class for extracting trial data from an XDF file for BCIP. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    sess : Session Object</span>
<span class="sd">        Session where the BcipXDF data source will exist.</span>

<span class="sd">    files : list of str</span>
<span class="sd">        XDF file(s) where data should be extracted from.</span>

<span class="sd">        </span>
<span class="sd">    tasks : list or tuple of strings </span>
<span class="sd">        List or Tuple of strings corresponding to the tasks to be completed by the user.</span>
<span class="sd">        For P300-type setups, the tasks &#39;target&#39; and &#39;non-target&#39;/&#39;flash&#39; can be used.</span>

<span class="sd">    channels : list or tuple of int</span>
<span class="sd">        Values corresponding to the EEG channels used during the session</span>

<span class="sd">    relative_start : float, default = 0</span>
<span class="sd">        Value corresponding to the start of the trial relative to the marker onset.</span>

<span class="sd">    Ns : int, default = 1</span>
<span class="sd">        Number of samples to be extracted per trial. For epoched data, this value determines the</span>
<span class="sd">        size of each epoch, whereas this value is used in polling for continuous data.    </span>
<span class="sd">        </span>
<span class="sd">    mode : &#39;continuous&#39; or &#39;epoched&#39;, default = &#39;epoched&#39;</span>
<span class="sd">        Mode indicates whether the inputted data will be epoched, by class,</span>
<span class="sd">        into individual trials, or to leave the data in a continuous format</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;epoched&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new xdf file reader interface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="n">files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span> <span class="o">=</span> <span class="n">relative_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="n">Ns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="n">tasks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        
        <span class="n">trial_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">task</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">}</span>
        
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;epoched&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">pyxdf</span><span class="o">.</span><span class="n">load_xdf</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">stream</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    
                    <span class="k">if</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Marker&#39;</span> <span class="ow">or</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Markers&#39;</span><span class="p">:</span> <span class="c1">#change to Markers after testing</span>
                        <span class="n">marker_stream</span> <span class="o">=</span> <span class="n">stream</span>
    
                    <span class="k">elif</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;EEG&#39;</span><span class="p">:</span>
                        <span class="n">eeg_stream</span> <span class="o">=</span> <span class="n">stream</span>
                
                <span class="n">Fs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;nominal_srate&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                    
                <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="c1"># used to extract EEG samples, pre-allocated here</span>
    
                <span class="c1">#print(eeg_stream[&#39;time_series&#39;].shape)</span>
                <span class="n">total_tasks</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i_m</span><span class="p">,</span> <span class="n">markers</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">]):</span>
                    <span class="n">marker_value</span> <span class="o">=</span> <span class="n">markers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">curr_task</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                                        
                    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">marker_value</span><span class="p">:</span>
                            <span class="n">curr_task</span> <span class="o">=</span> <span class="n">task</span>
    
                            <span class="n">marker_time</span> <span class="o">=</span> <span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="n">i_m</span><span class="p">]</span>
                            <span class="n">total_tasks</span> <span class="o">+=</span> <span class="mi">1</span>
                            
                            <span class="c1"># compute the 5s window, 2s after cue</span>
                            <span class="n">eeg_window_start</span> <span class="o">=</span> <span class="n">marker_time</span> <span class="o">-</span> <span class="n">relative_start</span>
                            <span class="c1">#eeg_window_end = marker_time + 0.8 +(5/Fs) # Added temporal buffer to limit indexing errors</span>
        
                            <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">eeg_window_start</span><span class="p">)</span>
                            
                            <span class="n">sample_data</span> <span class="o">=</span> <span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">][</span><span class="n">sample_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">channels</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="c1"># Nc X len(eeg_stream)</span>
                            <span class="n">trial_data</span><span class="p">[</span><span class="n">curr_task</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_data</span><span class="p">[:,</span> <span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">Ns</span><span class="p">)])</span> <span class="c1">#Nc x Ns</span>
                                


        
            <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">trial_data</span><span class="p">:</span>
                <span class="n">trial_data</span><span class="p">[</span><span class="n">task</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">trial_data</span><span class="p">[</span><span class="n">task</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Nt x Nc x Ns</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span> <span class="o">=</span> <span class="n">trial_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span> <span class="o">=</span> <span class="p">{</span><span class="n">task</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">}</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
            
            <span class="n">eeg_stream</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">marker_stream</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">pyxdf</span><span class="o">.</span><span class="n">load_xdf</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                
                <span class="k">for</span> <span class="n">stream</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Marker&#39;</span> <span class="ow">or</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Markers&#39;</span><span class="p">:</span> <span class="c1">#change to Markers after testing</span>
                        <span class="k">if</span> <span class="n">marker_stream</span><span class="p">:</span>
                            <span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">marker_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">marker_stream</span> <span class="o">=</span> <span class="n">stream</span>
    
                    <span class="k">elif</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;EEG&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">eeg_stream</span><span class="p">:</span>
                            <span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;time_series&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">eeg_stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">],</span> <span class="n">stream</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">eeg_stream</span> <span class="o">=</span> <span class="n">stream</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;EEG&#39;</span><span class="p">:</span> <span class="n">eeg_stream</span><span class="p">,</span> <span class="s1">&#39;Markers&#39;</span><span class="p">:</span> <span class="n">marker_stream</span><span class="p">}</span> 
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">100</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;Markers&#39;</span><span class="p">][</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">10</span><span class="p">:])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span> <span class="o">=</span> <span class="p">{</span><span class="n">task</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">}</span>

<div class="viewcode-block" id="BcipXDF.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipXDF.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1">#TODO: implement polling</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Polls the data source for new data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        label : string</span>
<span class="sd">            Marker to be used for polling. Number of trials previously extracted is recorded internally.</span>
<span class="sd">            This marker must be present in the XDF file and must be present in the list of tasks used in</span>
<span class="sd">            initialization.</span>

<span class="sd">        Ns : int, default = 1</span>
<span class="sd">            Number of samples to be extracted per trial. For continuous data, determines the size of</span>
<span class="sd">            the extracted sample. This value is disregarded for epoched data.   </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;epoched&#39;</span><span class="p">:</span>
            <span class="c1"># Extract sample data from epoched trial data and increment the label counter</span>
            <span class="n">sample_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">sample_data</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
            <span class="c1"># Find the index of the marker in the marker stream data</span>
            <span class="n">lst_of_marker_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;Markers&#39;</span><span class="p">][</span><span class="s1">&#39;time_series&#39;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;Markers&#39;</span><span class="p">][</span><span class="s1">&#39;time_series&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;Markers&#39;</span><span class="p">][</span><span class="s1">&#39;time_series&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">lst_of_marker_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            
            <span class="n">index</span> <span class="o">=</span> <span class="n">lst_of_marker_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span><span class="p">[</span><span class="n">label</span><span class="p">]]</span>
            
            <span class="c1"># Extract the corresponding marker timestamp</span>
            <span class="n">eeg_window_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;Markers&#39;</span><span class="p">][</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span>

            <span class="c1"># Construct the boolean array for samples that fall after the marker timestamp</span>
            <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">eeg_window_start</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">eeg_window_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="n">sample_indices</span><span class="p">][</span><span class="mi">179</span><span class="p">])</span>
            <span class="c1">#while np.sum(sample_indices) &lt; Ns:</span>
            <span class="c1">#    eeg_window_start = eeg_window_start + (.2*self.relative_start)</span>

                <span class="c1"># Construct the boolean array for samples that fall after the marker timestamp</span>
            <span class="c1">#    sample_indices = np.array(self.trial_data[&#39;EEG&#39;][&#39;time_stamps&#39;] &gt;= eeg_window_start)</span>

            
            <span class="n">sample_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trial_data</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][</span><span class="s1">&#39;time_series&#39;</span><span class="p">][</span><span class="n">sample_indices</span><span class="p">,</span> <span class="p">:][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="c1"># Nc X len(eeg_stream)</span>
            <span class="n">sample_data</span> <span class="o">=</span> <span class="n">sample_data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">Ns</span><span class="p">]</span> <span class="c1">#Nc x Ns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_counter</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">sample_data</span></div>
    
<div class="viewcode-block" id="BcipXDF.create_continuous"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipXDF.create_continuous">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_continuous</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory Method for creating continuous XDF File input source. </span>

<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        sess : Session Object</span>
<span class="sd">            Session where the BcipXDF data source will exist.</span>

<span class="sd">        files : list of str</span>
<span class="sd">            XDF file(s) where data should be extracted from.</span>
<span class="sd">       </span>
<span class="sd">        tasks : list or tuple of strings </span>
<span class="sd">            List or Tuple of strings corresponding to the tasks to be completed by the user.</span>
<span class="sd">            For P300-type setups, the tasks &#39;target&#39; and &#39;non-target&#39;/&#39;flash&#39; can be used.</span>

<span class="sd">        channels : list or tuple of int</span>
<span class="sd">            Values corresponding to the EEG channels used during the session</span>

<span class="sd">        relative_start : float, default = 0</span>
<span class="sd">            Value corresponding to the start of the trial relative to the marker onset.</span>

<span class="sd">        Ns : int, default = 1</span>
<span class="sd">            Number of samples to be extracted per trial. For epoched data, this value determines the</span>
<span class="sd">            size of each epoch, whereas this value is used in polling for continuous data. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;continuous&#39;</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span></div>

<div class="viewcode-block" id="BcipXDF.create_epoched"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipXDF.create_epoched">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_epoched</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory Method for creating epoched XDF File input source. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        sess : Session Object</span>
<span class="sd">            Session where the BcipXDF data source will exist.</span>

<span class="sd">        files : list of str</span>
<span class="sd">            XDF file(s) where data should be extracted from.</span>
<span class="sd">       </span>
<span class="sd">        tasks : list or tuple of strings </span>
<span class="sd">            List or Tuple of strings corresponding to the tasks to be completed by the user.</span>
<span class="sd">            For P300-type setups, the tasks &#39;target&#39; and &#39;non-target&#39;/&#39;flash&#39; can be used.</span>

<span class="sd">        channels : list or tuple of int</span>
<span class="sd">            Values corresponding to the EEG channels used during the session</span>

<span class="sd">        relative_start : float, default = 0</span>
<span class="sd">            Value corresponding to the start of the trial relative to the marker onset.</span>

<span class="sd">        Ns : int, default = 1</span>
<span class="sd">            Number of samples to be extracted per trial. For epoched data, this value determines the</span>
<span class="sd">            size of each epoch, whereas this value is used in polling for continuous data.    </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;epoched&#39;</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span></div>
    
<div class="viewcode-block" id="BcipXDF.create"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.BcipXDF.create">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ns</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;epoched&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory Method for creating epoched XDF File input source. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        sess : Session Object</span>
<span class="sd">            Session where the BcipXDF data source will exist.</span>

<span class="sd">        files : list of str</span>
<span class="sd">            XDF file(s) where data should be extracted from.</span>
<span class="sd">       </span>
<span class="sd">        tasks : list or tuple of strings </span>
<span class="sd">            List or Tuple of strings corresponding to the tasks to be completed by the user.</span>
<span class="sd">            For P300-type setups, the tasks &#39;target&#39; and &#39;non-target&#39;/&#39;flash&#39; can be used.</span>

<span class="sd">        channels : list or tuple of int</span>
<span class="sd">            Values corresponding to the EEG channels used during the session</span>

<span class="sd">        relative_start : float, default = 0</span>
<span class="sd">            Value corresponding to the start of the trial relative to the marker onset.</span>

<span class="sd">        Ns : int, default = 1</span>
<span class="sd">            Number of samples to be extracted per trial. For epoched data, this value determines the</span>
<span class="sd">            size of each epoch, whereas this value is used in polling for continuous data.    </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
    
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">files</span><span class="p">,</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">src</span></div></div>


<div class="viewcode-block" id="LSLStream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.LSLStream">[docs]</a><span class="k">class</span> <span class="nc">LSLStream</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object for maintaining an LSL inlet</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span><span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">marker_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">marker_pred</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new LSL inlet stream object</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>
<span class="sd">        pred : str</span>
<span class="sd">            The predicate string, e.g. &quot;name=&#39;BioSemi&#39;&quot; or &quot;type=&#39;EEG&#39; and starts-with(name,&#39;BioSemi&#39;) and </span>
<span class="sd">            count(description/desc/channels/channel)=32&quot;</span>
<span class="sd">        prop_value : str</span>
<span class="sd">            Property value of the target stream</span>
<span class="sd">        channels : tuple of ints</span>
<span class="sd">            Index value of channels to poll from the stream, if None all channels will be polled</span>
<span class="sd">        marker : bool</span>
<span class="sd">            true if there is an associated marker to indicate relative time where data should begin to be polled</span>
<span class="sd">        marker_fmt : str</span>
<span class="sd">            Regular expression template of the marker to be matched, if none all markers will be matched</span>
<span class="sd">        marker_pred : str</span>
<span class="sd">            The predicate string for the marker stream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="c1"># resolve the stream on the LSL network</span>
        <span class="n">available_streams</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">resolve_bypred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_streams</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO log error</span>
            <span class="k">return</span>
        
        <span class="c1"># TODO - Warn about more than one available stream</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamInlet</span><span class="p">(</span><span class="n">available_streams</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># for now, just take the first available stream that matches the property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># TODO - check if the stream has enough input channels to match the</span>
        <span class="c1"># channels parameter</span>
        <span class="k">if</span> <span class="n">channels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span><span class="o">.</span><span class="n">channel_count</span><span class="p">)])</span>
        
        <span class="k">if</span> <span class="n">marker</span><span class="p">:</span>
            <span class="n">marker_streams</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">resolve_bypred</span><span class="p">(</span><span class="n">marker_pred</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamInlet</span><span class="p">(</span><span class="n">marker_streams</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># for now, just take the first available marker stream</span>
            <span class="c1"># open the inlet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span><span class="o">.</span><span class="n">open_stream</span><span class="p">()</span>
        
            <span class="k">if</span> <span class="n">marker_fmt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">marker_fmt</span><span class="p">)</span>

    
<div class="viewcode-block" id="LSLStream.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.LSLStream.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pull data from the inlet stream until we have Ns data points for each</span>
<span class="sd">        channel.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ns: int</span>
<span class="sd">            number of samples to collect</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># start by getting the timestamp for this trial&#39;s marker</span>
            <span class="n">t_begin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">t_begin</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span><span class="o">.</span><span class="n">pull_sample</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">marker</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># extract the string portion of the marker</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">marker</span><span class="p">):</span>
                        <span class="n">t_begin</span> <span class="o">=</span> <span class="n">t</span>
                    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_begin</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># i.e. all data is valid</span>
        
        <span class="c1"># pull the data in chunks until we get the total number of samples</span>
        <span class="n">trial_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="n">Ns</span><span class="p">))</span> <span class="c1"># allocate the array</span>
        <span class="n">samples_polled</span> <span class="o">=</span> <span class="mi">0</span>        

        <span class="k">while</span> <span class="n">samples_polled</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span><span class="o">.</span><span class="n">pull_chunk</span><span class="p">()</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">timestamps</span> <span class="o">&gt;</span> <span class="n">t_begin</span><span class="p">):</span>
                <span class="c1"># convert data to numpy arrays</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="c1"># throw away data that comes after t_begin</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">timestamps</span> <span class="o">&gt;</span> <span class="n">t_begin</span><span class="p">]</span>
                <span class="n">chunk_sz</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>            

                <span class="c1"># append the latest chunk to the trial_data array</span>
                <span class="k">if</span> <span class="n">samples_polled</span> <span class="o">+</span> <span class="n">chunk_sz</span> <span class="o">&gt;</span> <span class="n">Ns</span><span class="p">:</span>
                    <span class="n">dest_end_index</span> <span class="o">=</span> <span class="n">Ns</span>
                    <span class="n">src_end_index</span> <span class="o">=</span> <span class="n">Ns</span> <span class="o">-</span> <span class="n">samples_polled</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dest_end_index</span> <span class="o">=</span> <span class="n">samples_polled</span> <span class="o">+</span> <span class="n">chunk_sz</span>
                    <span class="n">src_end_index</span> <span class="o">=</span> <span class="n">chunk_sz</span>

                <span class="n">trial_data</span><span class="p">[:,</span><span class="n">samples_polled</span><span class="p">:</span><span class="n">dest_end_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,:</span><span class="n">src_end_index</span><span class="p">]</span>
                <span class="n">samples_polled</span> <span class="o">+=</span> <span class="n">chunk_sz</span>
        
        
        <span class="k">return</span> <span class="n">trial_data</span></div>
    
<div class="viewcode-block" id="LSLStream.create_marker_coupled_data_stream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.LSLStream.create_marker_coupled_data_stream">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_marker_coupled_data_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">prop_value</span><span class="p">,</span>
                                          <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">marker_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a LSLStream data object that maintains a data stream and a</span>
<span class="sd">        marker stream</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">prop_value</span><span class="p">,</span><span class="n">channels</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="n">marker_fmt</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div>
    
<div class="viewcode-block" id="LSLStream.create_marker_uncoupled_data_stream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.LSLStream.create_marker_uncoupled_data_stream">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_marker_uncoupled_data_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">prop_value</span><span class="p">,</span>
                                            <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                            <span class="n">marker_fmt</span><span class="o">=</span><span class="s2">&quot;T</span><span class="si">{}</span><span class="s2">,L</span><span class="si">{}</span><span class="s2">,LN</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a LSLStream data object that maintains only a data stream with</span>
<span class="sd">        no associated marker stream</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span><span class="n">prop</span><span class="p">,</span><span class="n">prop_value</span><span class="p">,</span><span class="n">channels</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div></div>


<div class="viewcode-block" id="InputLSLStream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.InputLSLStream">[docs]</a><span class="k">class</span> <span class="nc">InputLSLStream</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object for maintaining an LSL inlet</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    data_buffer : dict - {&#39;EEG&#39;: np.array, &#39;time_stamps&#39;: np.array}</span>
<span class="sd">        A dictionary containing the data and time stamps from past samples (used when trials have overlapping data)</span>

<span class="sd">    data_inlet : pylsl.StreamInlet</span>
<span class="sd">        The LSL inlet object</span>

<span class="sd">    marker_inlet : pylsl.StreamInlet</span>
<span class="sd">        The LSL inlet object for the marker stream</span>

<span class="sd">    marker_pattern : re.Pattern</span>
<span class="sd">        The regular expression pattern for the marker stream. Use &quot;task1$|task2$|task3$&quot; if task1, task2, and task3 are the markers</span>

<span class="sd">    channels : tuple of ints</span>
<span class="sd">        Index value of channels to poll from the stream, if None all channels will be polled.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span><span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="n">marker</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">marker_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">marker_pred</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new LSL inlet stream object</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>
<span class="sd">        pred : str</span>
<span class="sd">            The predicate string, e.g. &quot;name=&#39;BioSemi&#39;&quot; or &quot;type=&#39;EEG&#39; and starts-with(name,&#39;BioSemi&#39;) and </span>
<span class="sd">            count(description/desc/channels/channel)=32&quot;</span>
<span class="sd">        channels : tuple of ints</span>
<span class="sd">            Index value of channels to poll from the stream, if None all channels will be polled</span>
<span class="sd">        relative_start : float, default = 0</span>
<span class="sd">            Duration of tiem before marker from which samples should be extracted during polling.</span>

<span class="sd">        marker : bool</span>
<span class="sd">            true if there is an associated marker to indicate relative time where data should begin to be polled</span>
<span class="sd">        marker_fmt : Regex or list</span>
<span class="sd">            Regular expression template of the marker to be matched, if none all markers will be matched. Alternatively, a list of markers can be provided.</span>
<span class="sd">        marker_pred : str</span>
<span class="sd">            The predicate string for the marker stream</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="c1"># resolve the stream on the LSL network</span>
        <span class="n">available_streams</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">resolve_bypred</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_streams</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO log error</span>
            <span class="k">return</span>
        
        <span class="c1"># TODO - Warn about more than one available stream</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;EEG&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamInlet</span><span class="p">(</span><span class="n">available_streams</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># for now, just take the first available stream that matches the property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span> <span class="o">=</span> <span class="n">relative_start</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># TODO - check if the stream has enough input channels to match the</span>
        <span class="c1"># channels parameter</span>
        <span class="k">if</span> <span class="n">channels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span><span class="o">.</span><span class="n">channel_count</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">marker</span><span class="p">:</span>
            <span class="n">marker_streams</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">resolve_bypred</span><span class="p">(</span><span class="n">marker_pred</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">marker_streams</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamInlet</span><span class="p">(</span><span class="n">marker_streams</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># for now, just take the first available marker stream</span>
            <span class="c1"># open the inlet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span><span class="o">.</span><span class="n">open_stream</span><span class="p">()</span>
        
            <span class="k">if</span> <span class="n">marker_fmt</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker_fmt</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                    <span class="n">marker_fmt</span> <span class="o">=</span> <span class="s1">&#39;$|^&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">marker_fmt</span><span class="p">)</span>
                    <span class="n">marker_fmt</span> <span class="o">=</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="n">marker_fmt</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span> 
                
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">marker_fmt</span><span class="p">)</span>

<div class="viewcode-block" id="InputLSLStream.poll_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.InputLSLStream.poll_data">[docs]</a>    <span class="k">def</span> <span class="nf">poll_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pull data from the inlet stream until we have Ns data points for each</span>
<span class="sd">        channel.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ns: int</span>
<span class="sd">            number of samples to collect</span>
<span class="sd">        Label : None</span>
<span class="sd">            used for file-based polling, not used here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># start by getting the timestamp for this trial&#39;s marker</span>
            <span class="n">t_begin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">t_begin</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">marker</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_inlet</span><span class="o">.</span><span class="n">pull_sample</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;marker: &quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">marker</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># extract the string portion of the marker</span>
                    <span class="c1">#print(marker)</span>
                    <span class="c1">#print(self.marker_pattern)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">marker</span><span class="p">):</span>
                        <span class="n">t_begin</span> <span class="o">=</span> <span class="n">t</span>
                        <span class="c1">#print(t_begin)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t_begin</span><span class="p">)</span>
                    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t_begin</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># i.e. all data is valid</span>
        
        <span class="n">t_begin</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_start</span>
        <span class="c1"># pull the data in chunks until we get the total number of samples</span>
        <span class="n">trial_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">),</span> <span class="n">Ns</span><span class="p">))</span> <span class="c1"># allocate the array</span>
        <span class="n">trial_timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ns</span><span class="p">,))</span>
        <span class="n">samples_polled</span> <span class="o">=</span> <span class="mi">0</span>        

        <span class="c1"># First, pull the data required data from the buffer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eeg_index_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">t_begin</span><span class="p">)</span>

            <span class="n">samples_polled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eeg_index_bool</span><span class="p">)</span>
            <span class="c1">#print(eeg_index_bool)</span>
            <span class="c1">#print(self.data_buffer[&#39;time_stamps&#39;])</span>
            <span class="n">trial_data</span><span class="p">[:,:</span><span class="n">samples_polled</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">][:,:][:,</span><span class="n">eeg_index_bool</span><span class="p">]</span>
            <span class="c1">#print(trial_timestamps)</span>
            <span class="n">trial_timestamps</span><span class="p">[:</span><span class="n">samples_polled</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">][</span><span class="n">eeg_index_bool</span><span class="p">]</span>
            <span class="c1">#print(&quot;Last time stamp in buffer:&quot;, self.data_buffer[&#39;time_stamps&#39;][-1])</span>
            <span class="c1">#print(eeg_index_bool)</span>
            <span class="c1">#if len(eeg_index_bool) &gt; 700:</span>
            <span class="c1">#    print(trial_timestamps)</span>
            <span class="c1">#print(&quot;First zero value in pre-LSL trial data: &quot;, np.argmax(trial_timestamps==0.))</span>
            <span class="c1">#print(&quot;Samples pulled from the buffer: &quot;, samples_polled)</span>
            <span class="c1">#print(f&quot;trials_timestamps shape: {self.data_buffer[&#39;time_stamps&#39;].shape}&quot;)</span>

        <span class="c1">#print(f&quot;T-BEGIN:`{t_begin}`&quot;)</span>
        <span class="k">while</span> <span class="n">samples_polled</span> <span class="o">&lt;</span> <span class="n">Ns</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_inlet</span><span class="o">.</span><span class="n">pull_chunk</span><span class="p">()</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">timestamps</span> <span class="o">&gt;=</span> <span class="n">t_begin</span><span class="p">):</span>
                <span class="c1">#print(f&quot;Number of new trials added to trial data: {np.sum(timestamps &gt;= t_begin)}&quot;)</span>
                <span class="c1"># convert data to numpy arrays</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">timestamps_index_bool</span> <span class="o">=</span> <span class="n">timestamps</span> <span class="o">&gt;=</span> <span class="n">t_begin</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,:][:,</span><span class="n">timestamps_index_bool</span><span class="p">]</span>
                <span class="n">timestamps</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[</span><span class="n">timestamps_index_bool</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">chunk_sz</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># append the latest chunk to the trial_data array</span>
                    <span class="k">if</span> <span class="n">samples_polled</span> <span class="o">+</span> <span class="n">chunk_sz</span> <span class="o">&gt;</span> <span class="n">Ns</span><span class="p">:</span>
                        <span class="n">dest_end_index</span> <span class="o">=</span> <span class="n">Ns</span>
                        <span class="n">src_end_index</span> <span class="o">=</span> <span class="n">Ns</span> <span class="o">-</span> <span class="n">samples_polled</span>
                    
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dest_end_index</span> <span class="o">=</span> <span class="n">samples_polled</span> <span class="o">+</span> <span class="n">chunk_sz</span>
                        <span class="n">src_end_index</span> <span class="o">=</span> <span class="n">chunk_sz</span>
                    
                    <span class="n">trial_data</span><span class="p">[:,</span> <span class="n">samples_polled</span><span class="p">:</span><span class="n">dest_end_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,:</span><span class="n">src_end_index</span><span class="p">]</span>
                    <span class="n">trial_timestamps</span><span class="p">[</span><span class="n">samples_polled</span><span class="p">:</span><span class="n">dest_end_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamps</span><span class="p">[:</span><span class="n">src_end_index</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">dest_end_index</span> <span class="o">==</span> <span class="n">Ns</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;EEG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">trial_data</span><span class="p">,</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">src_end_index</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>                                
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_buffer</span><span class="p">[</span><span class="s1">&#39;time_stamps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">trial_timestamps</span><span class="p">,</span> <span class="n">timestamps</span><span class="p">[</span><span class="n">src_end_index</span><span class="p">:]))</span>
                    

                    <span class="n">samples_polled</span> <span class="o">+=</span> <span class="n">chunk_sz</span> 
                        
                
        <span class="n">trial_data</span> <span class="o">=</span> <span class="n">trial_data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">Ns</span><span class="p">]</span> <span class="c1"># TODO remove?</span>

        <span class="k">return</span> <span class="n">trial_data</span></div>
    
<div class="viewcode-block" id="InputLSLStream.create_marker_coupled_data_stream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.InputLSLStream.create_marker_coupled_data_stream">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_marker_coupled_data_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">relative_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">marker_fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">marker_pred</span><span class="o">=</span><span class="s2">&quot;type=&#39;Markers&#39;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a LSLStream data object that maintains a data stream and a</span>
<span class="sd">        marker stream</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>
<span class="sd">        pred : str</span>
<span class="sd">            The predicate string, e.g. &quot;name=&#39;BioSemi&#39;&quot; or &quot;type=&#39;EEG&#39; and starts-with(name,&#39;BioSemi&#39;) and</span>
<span class="sd">            count(description/desc/channels/channel)=32&quot;</span>
<span class="sd">        channels : tuple or list of ints</span>
<span class="sd">            Index value of channels to poll from the stream, if None all channels will be polled</span>
<span class="sd">        marker_fmt : str</span>
<span class="sd">            Regular expression template of the marker to be matched, if none all markers will be matched</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span><span class="n">channels</span><span class="p">,</span><span class="n">relative_start</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="n">marker_fmt</span><span class="p">,</span><span class="n">marker_pred</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div>
    
<div class="viewcode-block" id="InputLSLStream.create_marker_uncoupled_data_stream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.InputLSLStream.create_marker_uncoupled_data_stream">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_marker_uncoupled_data_stream</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span><span class="n">channels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">relative_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">marker_fmt</span><span class="o">=</span><span class="s2">&quot;T</span><span class="si">{}</span><span class="s2">,L</span><span class="si">{}</span><span class="s2">,LN</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a LSLStream data object that maintains only a data stream with</span>
<span class="sd">        no associated marker stream</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>
<span class="sd">        pred : str</span>
<span class="sd">            The predicate string, e.g. &quot;name=&#39;BioSemi&#39;&quot; or &quot;type=&#39;EEG&#39; and starts-with(name,&#39;BioSemi&#39;) and</span>
<span class="sd">            count(description/desc/channels/channel)=32&quot;</span>
<span class="sd">        channels : tuple or list of ints</span>
<span class="sd">            Index value of channels to poll from the stream, if None all channels will be polled</span>
<span class="sd">        marker_fmt : str</span>
<span class="sd">            Regular expression template of the marker to be matched, if none all markers will be matched</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span><span class="n">pred</span><span class="p">,</span><span class="n">channels</span><span class="p">,</span> <span class="n">relative_start</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div></div>



<div class="viewcode-block" id="OutputLSLStream"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.OutputLSLStream">[docs]</a><span class="k">class</span> <span class="nc">OutputLSLStream</span><span class="p">(</span><span class="n">BCIP</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object for maintaining an LSL outlet</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">stream_info</span><span class="p">,</span> <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_buffer</span><span class="o">=</span><span class="mi">360</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Establish a new stream outlet. This makes the stream discoverable.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stream_info : StreamInfo</span>
<span class="sd">            StreamInfo object to describe this stream. Stays constant over the lifetime of the outlet.</span>
<span class="sd">        </span>
<span class="sd">        chunk_size : int, default = 0</span>
<span class="sd">            Optionally the desired chunk granularity (in samples) for transmission. </span>
<span class="sd">            If unspecified, each push operation yields one chunk. Inlets can override this setting. (default 0)</span>
<span class="sd">        </span>
<span class="sd">        max_buffered : default = 360</span>
<span class="sd">            The maximum amount of data to buffer (in seconds if there is a nominal sampling rate, otherwise </span>
<span class="sd">            x100 in samples). The default is 6 minutes of data. Note that, for high-bandwidth data, you will want to </span>
<span class="sd">            use a lower value here to avoid running out of RAM.</span>
<span class="sd">                        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">BcipEnums</span><span class="o">.</span><span class="n">SRC</span><span class="p">,</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="c1"># resolve the stream on the LSL network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsl_marker_outlet</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamOutlet</span><span class="p">(</span><span class="n">stream_info</span><span class="p">,</span><span class="n">chunk_size</span><span class="p">,</span><span class="n">max_buffer</span><span class="p">)</span>
        

<div class="viewcode-block" id="OutputLSLStream.push_data"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.OutputLSLStream.push_data">[docs]</a>    <span class="k">def</span> <span class="nf">push_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Push data to the outlet stream.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lsl_marker_outlet</span><span class="o">.</span><span class="n">push_sample</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
       
        <span class="k">return</span> <span class="n">BcipEnums</span><span class="o">.</span><span class="n">SUCCESS</span></div>
    
<div class="viewcode-block" id="OutputLSLStream.create_outlet_from_streaminfo"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.OutputLSLStream.create_outlet_from_streaminfo">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_outlet_from_streaminfo</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span> <span class="n">stream_info</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory method to create a OutletLSLStream bcipy object from a pylsl.StreamInfo object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>

<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>
<span class="sd">        stream_info : pylsl.StreamInfo object</span>
<span class="sd">            pylsl.StreamInfo object that describes the stream to be created</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">stream_info</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div>
    
<div class="viewcode-block" id="OutputLSLStream.create_outlet"><a class="viewcode-back" href="../../bcipy.html#bcipy.source.OutputLSLStream.create_outlet">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create_outlet</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">sess</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;untitled&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">channel_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nominal_srate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                          <span class="n">channel_format</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">source_id</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>    
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory Method to create an OutletLSLStream bcipy object from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        sess : session object</span>
<span class="sd">            Session object where the data source will exist</span>

<span class="sd">        name : str, default = &#39;untitled&#39;</span>
<span class="sd">            * Name of the stream. </span>
<span class="sd">            * Describes the device (or product series) that this stream makes available.</span>

<span class="sd">        type  str, default = &#39;&#39;</span>
<span class="sd">            * Content type of the stream. </span>
<span class="sd">            * By convention LSL uses the content types defined in the XDF file format specification where applicable. </span>
<span class="sd">        </span>
<span class="sd">        channel_count : int, default = 1</span>
<span class="sd">            * Number of channels per sample. This stays constant for the lifetime of the stream. </span>
<span class="sd">        </span>
<span class="sd">        nominal_srate : float, default = 0.0</span>
<span class="sd">            * The sampling rate (in Hz) as advertised by the data source.</span>

<span class="sd">        channel_format : int or str, default = 1</span>
<span class="sd">            * Format/type of each channel (ie. &#39;float32&#39;). </span>

<span class="sd">        source_id : str, default = &#39;&#39;</span>
<span class="sd">            * Unique identifier of the device or source of the data, if available (such as the serial number). </span>
<span class="sd">            * This is critical for system robustness since it allows recipients to recover from failure even after the serving app, device or computer crashes (just by finding a stream with the same source id on the network again). </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stream_info</span> <span class="o">=</span> <span class="n">pylsl</span><span class="o">.</span><span class="n">StreamInfo</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">channel_count</span><span class="p">,</span> <span class="n">nominal_srate</span><span class="p">,</span> <span class="n">channel_format</span><span class="p">,</span> <span class="n">source_id</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">stream_info</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">add_ext_src</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">src</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Nicolas Ivanov, Aaron Lio.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>